<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.14.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PRISMS-MP Manual: MatrixFreePDE&lt; dim, degree &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
  </script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeTabs.init()
  </script>
  <script type="text/javascript" src="version_selector_handler.js"></script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
              <td id="projectalign">
                <div id="projectname">PRISMS-MP Manual </div>
                <div id="projectnumber"></div> <!-- version selector will be injected here -->
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_matrix_free_p_d_e.html','','class_matrix_free_p_d_e-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MatrixFreePDE&lt; dim, degree &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>This is the abstract base class for the matrix free implementation of parabolic and elliptic BVP's, and supports MPI, threads and vectorization (Hybrid Parallel). This class contains the parallel data structures, mesh (referred to as triangulation), parallel degrees of freedom distribution, constraints, and general utility methods.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_free_p_d_e_8h_source.html">matrixFreePDE.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MatrixFreePDE&lt; dim, degree &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_matrix_free_p_d_e__inherit__graph.svg" width="159" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MatrixFreePDE&lt; dim, degree &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_matrix_free_p_d_e__coll__graph.svg" width="159" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa34a0d671bdb2fadf6f27c30a9cf9e4c" id="r_aa34a0d671bdb2fadf6f27c30a9cf9e4c"><td class="memItemLeft" align="right" valign="top"><a id="aa34a0d671bdb2fadf6f27c30a9cf9e4c" name="aa34a0d671bdb2fadf6f27c30a9cf9e4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixFreePDE</b> (<a class="el" href="classuser_input_parameters__pf.html">userInputParameters_pf</a>&lt; dim &gt;, <a class="el" href="classuser_input_parameters__cp.html">userInputParameters_cp</a> &amp;)</td></tr>
<tr class="memdesc:aa34a0d671bdb2fadf6f27c30a9cf9e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class contructor. <br /></td></tr>
<tr class="memitem:a721d5a97a58ee979bc2f1a01881553a3" id="r_a721d5a97a58ee979bc2f1a01881553a3"><td class="memItemLeft" align="right" valign="top"><a id="a721d5a97a58ee979bc2f1a01881553a3" name="a721d5a97a58ee979bc2f1a01881553a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~MatrixFreePDE</b> () override</td></tr>
<tr class="memdesc:a721d5a97a58ee979bc2f1a01881553a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. <br /></td></tr>
<tr class="memitem:a424d63479925745b85d462414d8144b9" id="r_a424d63479925745b85d462414d8144b9"><td class="memItemLeft" align="right" valign="top"><a id="a424d63479925745b85d462414d8144b9" name="a424d63479925745b85d462414d8144b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="memdesc:a424d63479925745b85d462414d8144b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the mesh, degrees of freedom, constraints and data structures using the user provided inputs in the application parameters file. <br /></td></tr>
<tr class="memitem:a30af094d1de94e09be86613649e62521" id="r_a30af094d1de94e09be86613649e62521"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30af094d1de94e09be86613649e62521">create_triangulation</a> (parallel::distributed::Triangulation&lt; dim &gt; &amp;tria) const</td></tr>
<tr class="memdesc:a30af094d1de94e09be86613649e62521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the mesh with the user provided domain sizes.  <br /></td></tr>
<tr class="memitem:a5e363551eb34d7f70c0ce1a50af7db9f" id="r_a5e363551eb34d7f70c0ce1a50af7db9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e363551eb34d7f70c0ce1a50af7db9f">initForTests</a> (std::vector&lt; <a class="el" href="class_field.html">Field</a>&lt; dim &gt; &gt; _fields)</td></tr>
<tr class="memdesc:a5e363551eb34d7f70c0ce1a50af7db9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the data structures for enabling unit tests.  <br /></td></tr>
<tr class="memitem:a7ccab91751f0903421789c8a12c06044" id="r_a7ccab91751f0903421789c8a12c06044"><td class="memItemLeft" align="right" valign="top"><a id="a7ccab91751f0903421789c8a12c06044" name="a7ccab91751f0903421789c8a12c06044"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> ()</td></tr>
<tr class="memdesc:a7ccab91751f0903421789c8a12c06044"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method implements the time stepping algorithm and invokes the <a class="el" href="#a700088789f8a17c13a76550bd964bd3b">solveIncrement()</a> method. <br /></td></tr>
<tr class="memitem:a9d7ff2d7a91aa703366bd302495b6678" id="r_a9d7ff2d7a91aa703366bd302495b6678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d7ff2d7a91aa703366bd302495b6678">vmult</a> (dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;dst, const dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;src) const</td></tr>
<tr class="memdesc:a9d7ff2d7a91aa703366bd302495b6678"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method essentially converts the <a class="el" href="class_matrix_free_p_d_e.html" title="This is the abstract base class for the matrix free implementation of parabolic and elliptic BVP&#39;s,...">MatrixFreePDE</a> object into a matrix object which can be used with matrix free iterative solvers. Provides the A*x functionality for solving the system of equations Ax=b.  <br /></td></tr>
<tr class="memitem:a784cf346a85baeb82d5c8fbed520bc0b" id="r_a784cf346a85baeb82d5c8fbed520bc0b"><td class="memItemLeft" align="right" valign="top"><a id="a784cf346a85baeb82d5c8fbed520bc0b" name="a784cf346a85baeb82d5c8fbed520bc0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildFields</b> ()</td></tr>
<tr class="memdesc:a784cf346a85baeb82d5c8fbed520bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the vector of all physical fields in the problem. <br /></td></tr>
<tr class="memitem:a22c9cf362995e00bae6a65de2f3fb6ef" id="r_a22c9cf362995e00bae6a65de2f3fb6ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22c9cf362995e00bae6a65de2f3fb6ef">setInitialCondition</a> (const Point&lt; dim &gt; &amp;p, const unsigned int index, double &amp;scalar_IC, Vector&lt; double &gt; &amp;vector_IC)=0</td></tr>
<tr class="memdesc:a22c9cf362995e00bae6a65de2f3fb6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial condition for all fields. This function is overriden in each application.  <br /></td></tr>
<tr class="memitem:a74ef35cfaad2e31975e8082b38441705" id="r_a74ef35cfaad2e31975e8082b38441705"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ef35cfaad2e31975e8082b38441705">setNonUniformDirichletBCs</a> (const Point&lt; dim &gt; &amp;p, const unsigned int index, const unsigned int direction, const double time, double &amp;scalar_BC, Vector&lt; double &gt; &amp;vector_BC)=0</td></tr>
<tr class="memdesc:a74ef35cfaad2e31975e8082b38441705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the spatially or temporally non-uniform boundary conditions. This function is overriden in each application.  <br /></td></tr>
<tr class="memitem:aec13845bf2ac3dc02e23acde6b9983b7" id="r_aec13845bf2ac3dc02e23acde6b9983b7"><td class="memItemLeft" align="right" valign="top"><a id="aec13845bf2ac3dc02e23acde6b9983b7" name="aec13845bf2ac3dc02e23acde6b9983b7"></a>
std::vector&lt; const DoFHandler&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDofHandlersSet</b> ()</td></tr>
<tr class="memitem:aa21cc7738708284e5967c21563c97f01" id="r_aa21cc7738708284e5967c21563c97f01"><td class="memItemLeft" align="right" valign="top"><a id="aa21cc7738708284e5967c21563c97f01" name="aa21cc7738708284e5967c21563c97f01"></a>
std::vector&lt; vectorType_pf * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSolutionSet</b> ()</td></tr>
<tr class="memitem:a58edcca332f8bc2db8b79f3f3e2b4f67" id="r_a58edcca332f8bc2db8b79f3f3e2b4f67"><td class="memItemLeft" align="right" valign="top"><a id="a58edcca332f8bc2db8b79f3f3e2b4f67" name="a58edcca332f8bc2db8b79f3f3e2b4f67"></a>
std::vector&lt; const AffineConstraints&lt; double &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getConstraintsDirichletSet</b> ()</td></tr>
<tr class="memitem:a7993ba4bfbeb17f17c60b83217ebe0d9" id="r_a7993ba4bfbeb17f17c60b83217ebe0d9"><td class="memItemLeft" align="right" valign="top"><a id="a7993ba4bfbeb17f17c60b83217ebe0d9" name="a7993ba4bfbeb17f17c60b83217ebe0d9"></a>
std::vector&lt; const AffineConstraints&lt; double &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getConstraintsOtherSet</b> ()</td></tr>
<tr class="memitem:a9b9a103b8f399c9a56937b467382d75a" id="r_a9b9a103b8f399c9a56937b467382d75a"><td class="memItemLeft" align="right" valign="top"><a id="a9b9a103b8f399c9a56937b467382d75a" name="a9b9a103b8f399c9a56937b467382d75a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getOutputResults</b> ()</td></tr>
<tr class="memitem:a7a01a74e9c37723a6499c5410498b27a" id="r_a7a01a74e9c37723a6499c5410498b27a"><td class="memItemLeft" align="right" valign="top"><a id="a7a01a74e9c37723a6499c5410498b27a" name="a7a01a74e9c37723a6499c5410498b27a"></a>
double &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentTime</b> ()</td></tr>
<tr class="memitem:a65faabb9193a72fdca08ba04dedbdc6a" id="r_a65faabb9193a72fdca08ba04dedbdc6a"><td class="memItemLeft" align="right" valign="top"><a id="a65faabb9193a72fdca08ba04dedbdc6a" name="a65faabb9193a72fdca08ba04dedbdc6a"></a>
unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentIncrement</b> ()</td></tr>
<tr class="memitem:a9a6a43a8b30de8d94b67c1b7eb884470" id="r_a9a6a43a8b30de8d94b67c1b7eb884470"><td class="memItemLeft" align="right" valign="top"><a id="a9a6a43a8b30de8d94b67c1b7eb884470" name="a9a6a43a8b30de8d94b67c1b7eb884470"></a>
unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentOutput</b> ()</td></tr>
<tr class="memitem:a700088789f8a17c13a76550bd964bd3b" id="r_a700088789f8a17c13a76550bd964bd3b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a700088789f8a17c13a76550bd964bd3b">solveIncrement</a> (bool skip_time_dependent)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5e77da924166e45e5f7f8d1b17873ea2" id="r_a5e77da924166e45e5f7f8d1b17873ea2"><td class="memItemLeft" align="right" valign="top"><a id="a5e77da924166e45e5f7f8d1b17873ea2" name="a5e77da924166e45e5f7f8d1b17873ea2"></a>
std::vector&lt; <a class="el" href="class_field.html">Field</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fields</b></td></tr>
<tr class="memdesc:a5e77da924166e45e5f7f8d1b17873ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of all the physical fields in the problem. Fields are identified by dimentionality (SCALAR/VECTOR), the kind of PDE (ELLIPTIC/PARABOLIC) used to compute them and a character identifier (e.g.: "c" for composition) which is used to write the fields to the output files. <br /></td></tr>
<tr class="memitem:a4c980b65b4311d177998ffae878768bc" id="r_a4c980b65b4311d177998ffae878768bc"><td class="memItemLeft" align="right" valign="top"><a id="a4c980b65b4311d177998ffae878768bc" name="a4c980b65b4311d177998ffae878768bc"></a>
ConditionalOStream&#160;</td><td class="memItemRight" valign="bottom"><b>pcout</b></td></tr>
<tr class="memdesc:a4c980b65b4311d177998ffae878768bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel message stream. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0e7a697f8759e6a3841e1bc4d9a431a6" id="r_a0e7a697f8759e6a3841e1bc4d9a431a6"><td class="memItemLeft" align="right" valign="top"><a id="a0e7a697f8759e6a3841e1bc4d9a431a6" name="a0e7a697f8759e6a3841e1bc4d9a431a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reinit</b> ()</td></tr>
<tr class="memitem:a7975eb6bc4ca5be5c4580a953336a0d3" id="r_a7975eb6bc4ca5be5c4580a953336a0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7975eb6bc4ca5be5c4580a953336a0d3">reassignGrains</a> ()</td></tr>
<tr class="memitem:ac8e5ea186b11639b588ad06295cdfc6d" id="r_ac8e5ea186b11639b588ad06295cdfc6d"><td class="memItemLeft" align="right" valign="top"><a id="ac8e5ea186b11639b588ad06295cdfc6d" name="ac8e5ea186b11639b588ad06295cdfc6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>outputResults</b> ()</td></tr>
<tr class="memitem:a76e0d56d6d113b38c8f93ac4ce3f3fd7" id="r_a76e0d56d6d113b38c8f93ac4ce3f3fd7"><td class="memItemLeft" align="right" valign="top"><a id="a76e0d56d6d113b38c8f93ac4ce3f3fd7" name="a76e0d56d6d113b38c8f93ac4ce3f3fd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeInvM</b> ()</td></tr>
<tr class="memitem:afbdc2122f434416ce7cc6f1c0fd3e3cf" id="r_afbdc2122f434416ce7cc6f1c0fd3e3cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbdc2122f434416ce7cc6f1c0fd3e3cf">refineGrid</a> ()</td></tr>
<tr class="memitem:aeca5bac74a396b8eae8963d22c8bd38e" id="r_aeca5bac74a396b8eae8963d22c8bd38e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca5bac74a396b8eae8963d22c8bd38e">adaptiveRefine</a> (unsigned int _currentIncrement_pf)</td></tr>
<tr class="memitem:a7aa854c057125670a0fe33aaa66fac7d" id="r_a7aa854c057125670a0fe33aaa66fac7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aa854c057125670a0fe33aaa66fac7d">adaptiveRefineCriterion</a> ()</td></tr>
<tr class="memitem:a60542db446660060b52fea4708be5688" id="r_a60542db446660060b52fea4708be5688"><td class="memItemLeft" align="right" valign="top"><a id="a60542db446660060b52fea4708be5688" name="a60542db446660060b52fea4708be5688"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateExplicitSolution</b> (unsigned int fieldIndex)</td></tr>
<tr class="memitem:ab93f2b5f1661fe57e3fc6a7d985adbf6" id="r_ab93f2b5f1661fe57e3fc6a7d985adbf6"><td class="memItemLeft" align="right" valign="top"><a id="ab93f2b5f1661fe57e3fc6a7d985adbf6" name="ab93f2b5f1661fe57e3fc6a7d985adbf6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateImplicitSolution</b> (unsigned int fieldIndex, unsigned int nonlinear_iteration_index)</td></tr>
<tr class="memitem:a54dfd2064b390ddbcc191bf071b0e8fc" id="r_a54dfd2064b390ddbcc191bf071b0e8fc"><td class="memItemLeft" align="right" valign="top"><a id="a54dfd2064b390ddbcc191bf071b0e8fc" name="a54dfd2064b390ddbcc191bf071b0e8fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyBCs</b> (unsigned int fieldIndex)</td></tr>
<tr class="memitem:a4a8eb6dcc5835c6dacb8d22c7ecfeef5" id="r_a4a8eb6dcc5835c6dacb8d22c7ecfeef5"><td class="memItemLeft" align="right" valign="top"><a id="a4a8eb6dcc5835c6dacb8d22c7ecfeef5" name="a4a8eb6dcc5835c6dacb8d22c7ecfeef5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compute_element_volume</b> ()</td></tr>
<tr class="memdesc:a4a8eb6dcc5835c6dacb8d22c7ecfeef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute element volume for the triangulation. <br /></td></tr>
<tr class="memitem:a62f03ede05a0ddafaad7b0be76fc9ed6" id="r_a62f03ede05a0ddafaad7b0be76fc9ed6"><td class="memItemLeft" align="right" valign="top"><a id="a62f03ede05a0ddafaad7b0be76fc9ed6" name="a62f03ede05a0ddafaad7b0be76fc9ed6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeExplicitRHS</b> ()</td></tr>
<tr class="memitem:a3276a070a166207a8984ba38c4cee9a2" id="r_a3276a070a166207a8984ba38c4cee9a2"><td class="memItemLeft" align="right" valign="top"><a id="a3276a070a166207a8984ba38c4cee9a2" name="a3276a070a166207a8984ba38c4cee9a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeNonexplicitRHS</b> ()</td></tr>
<tr class="memitem:a2dc5b0a925dae343cce3bd397365f14b" id="r_a2dc5b0a925dae343cce3bd397365f14b"><td class="memItemLeft" align="right" valign="top"><a id="a2dc5b0a925dae343cce3bd397365f14b" name="a2dc5b0a925dae343cce3bd397365f14b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getLHS</b> (const MatrixFree&lt; dim, double &gt; &amp;data, dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;dst, const dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;src, const std::pair&lt; unsigned int, unsigned int &gt; &amp;cell_range) const</td></tr>
<tr class="memitem:ac8c4408adad57956c0f1f9353b5d5827" id="r_ac8c4408adad57956c0f1f9353b5d5827"><td class="memItemLeft" align="right" valign="top"><a id="ac8c4408adad57956c0f1f9353b5d5827" name="ac8c4408adad57956c0f1f9353b5d5827"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getLaplaceLHS</b> (const MatrixFree&lt; dim, double &gt; &amp;data, dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;dst, const dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;src, const std::pair&lt; unsigned int, unsigned int &gt; &amp;cell_range) const</td></tr>
<tr class="memitem:a4bae86747006d1f8090ed30ee23b1ba4" id="r_a4bae86747006d1f8090ed30ee23b1ba4"><td class="memItemLeft" align="right" valign="top"><a id="a4bae86747006d1f8090ed30ee23b1ba4" name="a4bae86747006d1f8090ed30ee23b1ba4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNonlinearEqInitialGuess</b> ()</td></tr>
<tr class="memitem:a852fdbf2e8aaa13fd0b0b96e17384aa8" id="r_a852fdbf2e8aaa13fd0b0b96e17384aa8"><td class="memItemLeft" align="right" valign="top"><a id="a852fdbf2e8aaa13fd0b0b96e17384aa8" name="a852fdbf2e8aaa13fd0b0b96e17384aa8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeLaplaceRHS</b> (unsigned int fieldIndex)</td></tr>
<tr class="memitem:aa3b7f440ad196b912302d2f64a83f594" id="r_aa3b7f440ad196b912302d2f64a83f594"><td class="memItemLeft" align="right" valign="top"><a id="aa3b7f440ad196b912302d2f64a83f594" name="aa3b7f440ad196b912302d2f64a83f594"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getLaplaceRHS</b> (const MatrixFree&lt; dim, double &gt; &amp;data, dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;dst, const dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;src, const std::pair&lt; unsigned int, unsigned int &gt; &amp;cell_range) const</td></tr>
<tr class="memitem:a0288d9db6b145ebdbd239ad7227d1ae9" id="r_a0288d9db6b145ebdbd239ad7227d1ae9"><td class="memItemLeft" align="right" valign="top"><a id="a0288d9db6b145ebdbd239ad7227d1ae9" name="a0288d9db6b145ebdbd239ad7227d1ae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getExplicitRHS</b> (const MatrixFree&lt; dim, double &gt; &amp;data, std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;dst, const std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;src, const std::pair&lt; unsigned int, unsigned int &gt; &amp;cell_range) const</td></tr>
<tr class="memitem:ae0e6eb5e131df97a982dced3241b9555" id="r_ae0e6eb5e131df97a982dced3241b9555"><td class="memItemLeft" align="right" valign="top"><a id="ae0e6eb5e131df97a982dced3241b9555" name="ae0e6eb5e131df97a982dced3241b9555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getNonexplicitRHS</b> (const MatrixFree&lt; dim, double &gt; &amp;data, std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;dst, const std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;src, const std::pair&lt; unsigned int, unsigned int &gt; &amp;cell_range) const</td></tr>
<tr class="memitem:a3e6606a2d43f3947e528529c05179eb1" id="r_a3e6606a2d43f3947e528529c05179eb1"><td class="memItemLeft" align="right" valign="top"><a id="a3e6606a2d43f3947e528529c05179eb1" name="a3e6606a2d43f3947e528529c05179eb1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>explicitEquationRHS</b> (<a class="el" href="classvariable_container.html">variableContainer</a>&lt; dim, degree, VectorizedArray&lt; double &gt; &gt; &amp;variable_list, Point&lt; dim, VectorizedArray&lt; double &gt; &gt; q_point_loc) const =0</td></tr>
<tr class="memitem:a5346f319fe1913d2a73aed5d77215939" id="r_a5346f319fe1913d2a73aed5d77215939"><td class="memItemLeft" align="right" valign="top"><a id="a5346f319fe1913d2a73aed5d77215939" name="a5346f319fe1913d2a73aed5d77215939"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>nonExplicitEquationRHS</b> (<a class="el" href="classvariable_container.html">variableContainer</a>&lt; dim, degree, VectorizedArray&lt; double &gt; &gt; &amp;variable_list, Point&lt; dim, VectorizedArray&lt; double &gt; &gt; q_point_loc) const =0</td></tr>
<tr class="memitem:ae279770f4aa786ebc313ecaf0a2c3062" id="r_ae279770f4aa786ebc313ecaf0a2c3062"><td class="memItemLeft" align="right" valign="top"><a id="ae279770f4aa786ebc313ecaf0a2c3062" name="ae279770f4aa786ebc313ecaf0a2c3062"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>equationLHS</b> (<a class="el" href="classvariable_container.html">variableContainer</a>&lt; dim, degree, VectorizedArray&lt; double &gt; &gt; &amp;variable_list, Point&lt; dim, VectorizedArray&lt; double &gt; &gt; q_point_loc) const =0</td></tr>
<tr class="memitem:afff1759a8a434b5d427a9db34a761d0d" id="r_afff1759a8a434b5d427a9db34a761d0d"><td class="memItemLeft" align="right" valign="top"><a id="afff1759a8a434b5d427a9db34a761d0d" name="afff1759a8a434b5d427a9db34a761d0d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>postProcessedFields</b> (const <a class="el" href="classvariable_container.html">variableContainer</a>&lt; dim, degree, VectorizedArray&lt; double &gt; &gt; &amp;variable_list, <a class="el" href="classvariable_container.html">variableContainer</a>&lt; dim, degree, VectorizedArray&lt; double &gt; &gt; &amp;pp_variable_list, const Point&lt; dim, VectorizedArray&lt; double &gt; &gt; q_point_loc) const</td></tr>
<tr class="memitem:aa3bb39603ab996dda77316ba39b2f0cb" id="r_aa3bb39603ab996dda77316ba39b2f0cb"><td class="memItemLeft" align="right" valign="top"><a id="aa3bb39603ab996dda77316ba39b2f0cb" name="aa3bb39603ab996dda77316ba39b2f0cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computePostProcessedFields</b> (std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;postProcessedSet)</td></tr>
<tr class="memitem:aa4bd108e8c54cdcd6a19abe6710c300b" id="r_aa4bd108e8c54cdcd6a19abe6710c300b"><td class="memItemLeft" align="right" valign="top"><a id="aa4bd108e8c54cdcd6a19abe6710c300b" name="aa4bd108e8c54cdcd6a19abe6710c300b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getPostProcessedFields</b> (const MatrixFree&lt; dim, double &gt; &amp;data, std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;dst, const std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; &amp;src, const std::pair&lt; unsigned int, unsigned int &gt; &amp;cell_range)</td></tr>
<tr class="memitem:a34c4dbab48fd3fed6d78af32261eba07" id="r_a34c4dbab48fd3fed6d78af32261eba07"><td class="memItemLeft" align="right" valign="top"><a id="a34c4dbab48fd3fed6d78af32261eba07" name="a34c4dbab48fd3fed6d78af32261eba07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>markBoundaries</b> (parallel::distributed::Triangulation&lt; dim &gt; &amp;) const</td></tr>
<tr class="memitem:a05037ad643070beaf4abc4b4a304b5f2" id="r_a05037ad643070beaf4abc4b4a304b5f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05037ad643070beaf4abc4b4a304b5f2">applyDirichletBCs</a> ()</td></tr>
<tr class="memitem:a2af67badeaae89034d4cea840514a344" id="r_a2af67badeaae89034d4cea840514a344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af67badeaae89034d4cea840514a344">applyNeumannBCs</a> ()</td></tr>
<tr class="memitem:a6fe9eb603a0927733ed3bcc64a7ec99d" id="r_a6fe9eb603a0927733ed3bcc64a7ec99d"><td class="memItemLeft" align="right" valign="top"><a id="a6fe9eb603a0927733ed3bcc64a7ec99d" name="a6fe9eb603a0927733ed3bcc64a7ec99d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPeriodicity</b> ()</td></tr>
<tr class="memitem:a79c816dcf1f6a7918b88139623996cd6" id="r_a79c816dcf1f6a7918b88139623996cd6"><td class="memItemLeft" align="right" valign="top"><a id="a79c816dcf1f6a7918b88139623996cd6" name="a79c816dcf1f6a7918b88139623996cd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPeriodicityConstraints</b> (AffineConstraints&lt; double &gt; *constraints, const DoFHandler&lt; dim &gt; *dof_handler) const</td></tr>
<tr class="memitem:a705efc0da910b53ac9b1af860bbf4e41" id="r_a705efc0da910b53ac9b1af860bbf4e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705efc0da910b53ac9b1af860bbf4e41">setRigidBodyModeConstraints</a> (const std::vector&lt; int &gt; rigidBodyModeComponents, AffineConstraints&lt; double &gt; *constraints, const DoFHandler&lt; dim &gt; *dof_handler) const</td></tr>
<tr class="memdesc:a705efc0da910b53ac9b1af860bbf4e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set constraints to pin the solution to 0 at a certain vertex. This is automatically done at the origin if no value terms are detected in your dependencies in a time_independent or implicit solve.  <br /></td></tr>
<tr class="memitem:a21f38fd17bfefcb790a97be0849fc731" id="r_a21f38fd17bfefcb790a97be0849fc731"><td class="memItemLeft" align="right" valign="top"><a id="a21f38fd17bfefcb790a97be0849fc731" name="a21f38fd17bfefcb790a97be0849fc731"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getComponentsWithRigidBodyModes</b> (std::vector&lt; int &gt; &amp;) const</td></tr>
<tr class="memitem:a1028b76f695ae2795977cd5d0dc76a92" id="r_a1028b76f695ae2795977cd5d0dc76a92"><td class="memItemLeft" align="right" valign="top"><a id="a1028b76f695ae2795977cd5d0dc76a92" name="a1028b76f695ae2795977cd5d0dc76a92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyInitialConditions</b> ()</td></tr>
<tr class="memitem:a10880ae7dbadf9f651ffd8779510af7d" id="r_a10880ae7dbadf9f651ffd8779510af7d"><td class="memItemLeft" align="right" valign="top"><a id="a10880ae7dbadf9f651ffd8779510af7d" name="a10880ae7dbadf9f651ffd8779510af7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>save_checkpoint</b> ()</td></tr>
<tr class="memitem:a7eed93c2a80189c1b21492af2b169f4c" id="r_a7eed93c2a80189c1b21492af2b169f4c"><td class="memItemLeft" align="right" valign="top"><a id="a7eed93c2a80189c1b21492af2b169f4c" name="a7eed93c2a80189c1b21492af2b169f4c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>load_checkpoint_triangulation</b> ()</td></tr>
<tr class="memitem:aef22fdab4b8da625407c9530f5ad976e" id="r_aef22fdab4b8da625407c9530f5ad976e"><td class="memItemLeft" align="right" valign="top"><a id="aef22fdab4b8da625407c9530f5ad976e" name="aef22fdab4b8da625407c9530f5ad976e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>load_checkpoint_fields</b> ()</td></tr>
<tr class="memitem:a1db007deff62f362af72c6bf3408056f" id="r_a1db007deff62f362af72c6bf3408056f"><td class="memItemLeft" align="right" valign="top"><a id="a1db007deff62f362af72c6bf3408056f" name="a1db007deff62f362af72c6bf3408056f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>load_checkpoint_time_info</b> ()</td></tr>
<tr class="memitem:a47c5b0fe36a147e8485f1d9e24c1e034" id="r_a47c5b0fe36a147e8485f1d9e24c1e034"><td class="memItemLeft" align="right" valign="top"><a id="a47c5b0fe36a147e8485f1d9e24c1e034" name="a47c5b0fe36a147e8485f1d9e24c1e034"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_file</b> (const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memitem:ac4791d645d3445a260c4203eacf3632e" id="r_ac4791d645d3445a260c4203eacf3632e"><td class="memItemLeft" align="right" valign="top"><a id="ac4791d645d3445a260c4203eacf3632e" name="ac4791d645d3445a260c4203eacf3632e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>verify_checkpoint_file_exists</b> (const std::string &amp;filename)</td></tr>
<tr class="memitem:a7685ac9e93625d7c4e96d3b7ac72221b" id="r_a7685ac9e93625d7c4e96d3b7ac72221b"><td class="memItemLeft" align="right" valign="top"><a id="a7685ac9e93625d7c4e96d3b7ac72221b" name="a7685ac9e93625d7c4e96d3b7ac72221b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateNucleiList</b> ()</td></tr>
<tr class="memitem:ad81202b04cf45c222e3dab81ae86c91e" id="r_ad81202b04cf45c222e3dab81ae86c91e"><td class="memItemLeft" align="right" valign="top"><a id="ad81202b04cf45c222e3dab81ae86c91e" name="ad81202b04cf45c222e3dab81ae86c91e"></a>
std::vector&lt; <a class="el" href="structnucleus.html">nucleus</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNewNuclei</b> ()</td></tr>
<tr class="memitem:afb810895010a70cb45ffc57e34d98b78" id="r_afb810895010a70cb45ffc57e34d98b78"><td class="memItemLeft" align="right" valign="top"><a id="afb810895010a70cb45ffc57e34d98b78" name="afb810895010a70cb45ffc57e34d98b78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getLocalNucleiList</b> (std::vector&lt; <a class="el" href="structnucleus.html">nucleus</a>&lt; dim &gt; &gt; &amp;newnuclei) const</td></tr>
<tr class="memitem:ae82cc8d9c8dbe3163d647d298cff2b9e" id="r_ae82cc8d9c8dbe3163d647d298cff2b9e"><td class="memItemLeft" align="right" valign="top"><a id="ae82cc8d9c8dbe3163d647d298cff2b9e" name="ae82cc8d9c8dbe3163d647d298cff2b9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>safetyCheckNewNuclei</b> (std::vector&lt; <a class="el" href="structnucleus.html">nucleus</a>&lt; dim &gt; &gt; newnuclei, std::vector&lt; unsigned int &gt; &amp;conflict_ids)</td></tr>
<tr class="memitem:af1074daa03c9cc2c24e42adcd936ed75" id="r_af1074daa03c9cc2c24e42adcd936ed75"><td class="memItemLeft" align="right" valign="top"><a id="af1074daa03c9cc2c24e42adcd936ed75" name="af1074daa03c9cc2c24e42adcd936ed75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>refineMeshNearNuclei</b> (std::vector&lt; <a class="el" href="structnucleus.html">nucleus</a>&lt; dim &gt; &gt; newnuclei)</td></tr>
<tr class="memitem:a1a2c47308e31e86d9a1abe39fd4677a5" id="r_a1a2c47308e31e86d9a1abe39fd4677a5"><td class="memItemLeft" align="right" valign="top"><a id="a1a2c47308e31e86d9a1abe39fd4677a5" name="a1a2c47308e31e86d9a1abe39fd4677a5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>weightedDistanceFromNucleusCenter</b> (const Point&lt; dim, double &gt; center, const std::vector&lt; double &gt; &amp;semiaxes, const Point&lt; dim, double &gt; q_point_loc, const unsigned int var_index) const</td></tr>
<tr class="memitem:a4c4dbf70ac79743f3c56eddfb48a7582" id="r_a4c4dbf70ac79743f3c56eddfb48a7582"><td class="memItemLeft" align="right" valign="top"><a id="a4c4dbf70ac79743f3c56eddfb48a7582" name="a4c4dbf70ac79743f3c56eddfb48a7582"></a>
VectorizedArray&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weightedDistanceFromNucleusCenter</b> (const Point&lt; dim, double &gt; center, const std::vector&lt; double &gt; &amp;semiaxes, const Point&lt; dim, VectorizedArray&lt; double &gt; &gt; q_point_loc, const unsigned int var_index) const</td></tr>
<tr class="memitem:a503a52c2fe436c30c53f495ba34512b0" id="r_a503a52c2fe436c30c53f495ba34512b0"><td class="memItemLeft" align="right" valign="top"><a id="a503a52c2fe436c30c53f495ba34512b0" name="a503a52c2fe436c30c53f495ba34512b0"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>getNucleationProbability</b> (<a class="el" href="classvariable_value_container.html">variableValueContainer</a>, double, Point&lt; dim &gt;, unsigned int variable_index) const</td></tr>
<tr class="memitem:a78e0f4596340aca37f2da28425d4186b" id="r_a78e0f4596340aca37f2da28425d4186b"><td class="memItemLeft" align="right" valign="top"><a id="a78e0f4596340aca37f2da28425d4186b" name="a78e0f4596340aca37f2da28425d4186b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getFieldIndex</b> (std::string _name)</td></tr>
<tr class="memitem:ae8557b11b982247494f86939367c69ce" id="r_ae8557b11b982247494f86939367c69ce"><td class="memItemLeft" align="right" valign="top"><a id="ae8557b11b982247494f86939367c69ce" name="ae8557b11b982247494f86939367c69ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeIntegral</b> (double &amp;integratedField, int index, std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt; variableSet)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abe3befdc38d5ab0754cb2f6b6acd4e43" id="r_abe3befdc38d5ab0754cb2f6b6acd4e43"><td class="memItemLeft" align="right" valign="top"><a id="abe3befdc38d5ab0754cb2f6b6acd4e43" name="abe3befdc38d5ab0754cb2f6b6acd4e43"></a>
<a class="el" href="classuser_input_parameters__pf.html">userInputParameters_pf</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>userInputs</b></td></tr>
<tr class="memitem:a429e27f9a930163a2097a3142ba62f0b" id="r_a429e27f9a930163a2097a3142ba62f0b"><td class="memItemLeft" align="right" valign="top"><a id="a429e27f9a930163a2097a3142ba62f0b" name="a429e27f9a930163a2097a3142ba62f0b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>totalDOFs</b></td></tr>
<tr class="memitem:a34fe7ef9e12887c230af051226e8b5cc" id="r_a34fe7ef9e12887c230af051226e8b5cc"><td class="memItemLeft" align="right" valign="top"><a id="a34fe7ef9e12887c230af051226e8b5cc" name="a34fe7ef9e12887c230af051226e8b5cc"></a>
std::vector&lt; <a class="el" href="class_simplified_grain_representation.html">SimplifiedGrainRepresentation</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simplified_grain_representations</b></td></tr>
<tr class="memitem:ad3de5de465ef441e5baf977b2b059a61" id="r_ad3de5de465ef441e5baf977b2b059a61"><td class="memItemLeft" align="right" valign="top"><a id="ad3de5de465ef441e5baf977b2b059a61" name="ad3de5de465ef441e5baf977b2b059a61"></a>
parallel::distributed::Triangulation&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>triangulation</b></td></tr>
<tr class="memitem:a5bd2ed9df2ce8c418e66c085e42de979" id="r_a5bd2ed9df2ce8c418e66c085e42de979"><td class="memItemLeft" align="right" valign="top"><a id="a5bd2ed9df2ce8c418e66c085e42de979" name="a5bd2ed9df2ce8c418e66c085e42de979"></a>
std::vector&lt; FESystem&lt; dim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FESet</b></td></tr>
<tr class="memitem:af76a7462e273dcd848298e3add25dba3" id="r_af76a7462e273dcd848298e3add25dba3"><td class="memItemLeft" align="right" valign="top"><a id="af76a7462e273dcd848298e3add25dba3" name="af76a7462e273dcd848298e3add25dba3"></a>
std::vector&lt; const AffineConstraints&lt; double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>constraintsDirichletSet</b></td></tr>
<tr class="memitem:a3d3499d2f11fc3b02351598d0218961e" id="r_a3d3499d2f11fc3b02351598d0218961e"><td class="memItemLeft" align="right" valign="top"><a id="a3d3499d2f11fc3b02351598d0218961e" name="a3d3499d2f11fc3b02351598d0218961e"></a>
std::vector&lt; const AffineConstraints&lt; double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>constraintsOtherSet</b></td></tr>
<tr class="memitem:ab245fc9f042308cc6641aba38a7832e0" id="r_ab245fc9f042308cc6641aba38a7832e0"><td class="memItemLeft" align="right" valign="top"><a id="ab245fc9f042308cc6641aba38a7832e0" name="ab245fc9f042308cc6641aba38a7832e0"></a>
std::vector&lt; const DoFHandler&lt; dim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dofHandlersSet</b></td></tr>
<tr class="memitem:a1021699d921108205980bf0db02c6983" id="r_a1021699d921108205980bf0db02c6983"><td class="memItemLeft" align="right" valign="top"><a id="a1021699d921108205980bf0db02c6983" name="a1021699d921108205980bf0db02c6983"></a>
std::vector&lt; const IndexSet * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>locally_relevant_dofsSet</b></td></tr>
<tr class="memitem:a1bc073c0a69919b8121328fd2a330c0b" id="r_a1bc073c0a69919b8121328fd2a330c0b"><td class="memItemLeft" align="right" valign="top"><a id="a1bc073c0a69919b8121328fd2a330c0b" name="a1bc073c0a69919b8121328fd2a330c0b"></a>
std::vector&lt; AffineConstraints&lt; double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>constraintsDirichletSet_nonconst</b></td></tr>
<tr class="memitem:ab3fd32bf0b98d3bc93276bc220ce360c" id="r_ab3fd32bf0b98d3bc93276bc220ce360c"><td class="memItemLeft" align="right" valign="top"><a id="ab3fd32bf0b98d3bc93276bc220ce360c" name="ab3fd32bf0b98d3bc93276bc220ce360c"></a>
std::vector&lt; AffineConstraints&lt; double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>constraintsOtherSet_nonconst</b></td></tr>
<tr class="memitem:a8746e19e83867c76695361f27cff3feb" id="r_a8746e19e83867c76695361f27cff3feb"><td class="memItemLeft" align="right" valign="top"><a id="a8746e19e83867c76695361f27cff3feb" name="a8746e19e83867c76695361f27cff3feb"></a>
std::vector&lt; DoFHandler&lt; dim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dofHandlersSet_nonconst</b></td></tr>
<tr class="memitem:a7c77d4c9d2630f63a83244aadbf9b89f" id="r_a7c77d4c9d2630f63a83244aadbf9b89f"><td class="memItemLeft" align="right" valign="top"><a id="a7c77d4c9d2630f63a83244aadbf9b89f" name="a7c77d4c9d2630f63a83244aadbf9b89f"></a>
std::vector&lt; IndexSet * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>locally_relevant_dofsSet_nonconst</b></td></tr>
<tr class="memitem:a117d42226161b119970b094cd4f32e0b" id="r_a117d42226161b119970b094cd4f32e0b"><td class="memItemLeft" align="right" valign="top"><a id="a117d42226161b119970b094cd4f32e0b" name="a117d42226161b119970b094cd4f32e0b"></a>
std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>solutionSet</b></td></tr>
<tr class="memitem:a4c89495e870c6c3f51719b01cb8849c0" id="r_a4c89495e870c6c3f51719b01cb8849c0"><td class="memItemLeft" align="right" valign="top"><a id="a4c89495e870c6c3f51719b01cb8849c0" name="a4c89495e870c6c3f51719b01cb8849c0"></a>
std::vector&lt; dealii::LinearAlgebra::distributed::Vector&lt; double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>residualSet</b></td></tr>
<tr class="memitem:aa61caa683ce34dacdeb56b3588d6a6bf" id="r_aa61caa683ce34dacdeb56b3588d6a6bf"><td class="memItemLeft" align="right" valign="top"><a id="aa61caa683ce34dacdeb56b3588d6a6bf" name="aa61caa683ce34dacdeb56b3588d6a6bf"></a>
std::vector&lt; parallel::distributed::SolutionTransfer&lt; dim, dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>soltransSet</b></td></tr>
<tr class="memitem:a78bb31e87a18f6f23cc8bd66cd3b8666" id="r_a78bb31e87a18f6f23cc8bd66cd3b8666"><td class="memItemLeft" align="right" valign="top"><a id="a78bb31e87a18f6f23cc8bd66cd3b8666" name="a78bb31e87a18f6f23cc8bd66cd3b8666"></a>
MatrixFree&lt; dim, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>matrixFreeObject</b></td></tr>
<tr class="memitem:a6e5b612344fe83bd7fa2d48988782642" id="r_a6e5b612344fe83bd7fa2d48988782642"><td class="memItemLeft" align="right" valign="top"><a id="a6e5b612344fe83bd7fa2d48988782642" name="a6e5b612344fe83bd7fa2d48988782642"></a>
vectorType_pf&#160;</td><td class="memItemRight" valign="bottom"><b>invM</b></td></tr>
<tr class="memitem:a39118d5094c278e35fcb26fb3ce3271f" id="r_a39118d5094c278e35fcb26fb3ce3271f"><td class="memItemLeft" align="right" valign="top"><a id="a39118d5094c278e35fcb26fb3ce3271f" name="a39118d5094c278e35fcb26fb3ce3271f"></a>
vectorType_pf&#160;</td><td class="memItemRight" valign="bottom"><b>dU_vector</b></td></tr>
<tr class="memitem:a4ecfdc9a830f29fc2168892a352f7315" id="r_a4ecfdc9a830f29fc2168892a352f7315"><td class="memItemLeft" align="right" valign="top"><a id="a4ecfdc9a830f29fc2168892a352f7315" name="a4ecfdc9a830f29fc2168892a352f7315"></a>
vectorType_pf&#160;</td><td class="memItemRight" valign="bottom"><b>dU_scalar</b></td></tr>
<tr class="memitem:a6f53f45c0ab3c628a81bf776089fe2e4" id="r_a6f53f45c0ab3c628a81bf776089fe2e4"><td class="memItemLeft" align="right" valign="top"><a id="a6f53f45c0ab3c628a81bf776089fe2e4" name="a6f53f45c0ab3c628a81bf776089fe2e4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>currentFieldIndex</b></td></tr>
<tr class="memitem:a9459d1dc081821e304a6b14120312c79" id="r_a9459d1dc081821e304a6b14120312c79"><td class="memItemLeft" align="right" valign="top"><a id="a9459d1dc081821e304a6b14120312c79" name="a9459d1dc081821e304a6b14120312c79"></a>
dealii::AlignedVector&lt; dealii::VectorizedArray&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>element_volume</b></td></tr>
<tr class="memdesc:a9459d1dc081821e304a6b14120312c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that stores element volumes. <br /></td></tr>
<tr class="memitem:abf5fa02a9b877e514ad8d93e4a41c375" id="r_abf5fa02a9b877e514ad8d93e4a41c375"><td class="memItemLeft" align="right" valign="top"><a id="abf5fa02a9b877e514ad8d93e4a41c375" name="abf5fa02a9b877e514ad8d93e4a41c375"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>generatingInitialGuess</b></td></tr>
<tr class="memitem:ab7bbc2fa6097101ba69bee6c4881f149" id="r_ab7bbc2fa6097101ba69bee6c4881f149"><td class="memItemLeft" align="right" valign="top"><a id="ab7bbc2fa6097101ba69bee6c4881f149" name="ab7bbc2fa6097101ba69bee6c4881f149"></a>
std::vector&lt; std::map&lt; types::global_dof_index, double &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>valuesDirichletSet</b></td></tr>
<tr class="memitem:a07a2ef855d6249df1765abc6a7970014" id="r_a07a2ef855d6249df1765abc6a7970014"><td class="memItemLeft" align="right" valign="top"><a id="a07a2ef855d6249df1765abc6a7970014" name="a07a2ef855d6249df1765abc6a7970014"></a>
std::vector&lt; <a class="el" href="structnucleus.html">nucleus</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nuclei</b></td></tr>
<tr class="memitem:a34af03ff551acb2c284acd2afc2715e2" id="r_a34af03ff551acb2c284acd2afc2715e2"><td class="memItemLeft" align="right" valign="top"><a id="a34af03ff551acb2c284acd2afc2715e2" name="a34af03ff551acb2c284acd2afc2715e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isTimeDependentBVP</b></td></tr>
<tr class="memitem:a7204fed117054bc775f6cbc7c4a3b9a1" id="r_a7204fed117054bc775f6cbc7c4a3b9a1"><td class="memItemLeft" align="right" valign="top"><a id="a7204fed117054bc775f6cbc7c4a3b9a1" name="a7204fed117054bc775f6cbc7c4a3b9a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEllipticBVP</b></td></tr>
<tr class="memitem:ad75a30057628b2a29170adb8f6b4f53d" id="r_ad75a30057628b2a29170adb8f6b4f53d"><td class="memItemLeft" align="right" valign="top"><a id="ad75a30057628b2a29170adb8f6b4f53d" name="ad75a30057628b2a29170adb8f6b4f53d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasExplicitEquation</b></td></tr>
<tr class="memitem:aaeb626beee4a32bef7af5c8e4fc8fd68" id="r_aaeb626beee4a32bef7af5c8e4fc8fd68"><td class="memItemLeft" align="right" valign="top"><a id="aaeb626beee4a32bef7af5c8e4fc8fd68" name="aaeb626beee4a32bef7af5c8e4fc8fd68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasNonExplicitEquation</b></td></tr>
<tr class="memitem:a0a00e18617bfb8a4ab4d230eceeaeee5" id="r_a0a00e18617bfb8a4ab4d230eceeaeee5"><td class="memItemLeft" align="right" valign="top"><a id="a0a00e18617bfb8a4ab4d230eceeaeee5" name="a0a00e18617bfb8a4ab4d230eceeaeee5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>currentTime</b></td></tr>
<tr class="memitem:a2e3acf8635b09bd5a8983fefcebb94f7" id="r_a2e3acf8635b09bd5a8983fefcebb94f7"><td class="memItemLeft" align="right" valign="top"><a id="a2e3acf8635b09bd5a8983fefcebb94f7" name="a2e3acf8635b09bd5a8983fefcebb94f7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>currentIncrement</b></td></tr>
<tr class="memitem:a67ada0e4bd265f4555ad550dc7301fc0" id="r_a67ada0e4bd265f4555ad550dc7301fc0"><td class="memItemLeft" align="right" valign="top"><a id="a67ada0e4bd265f4555ad550dc7301fc0" name="a67ada0e4bd265f4555ad550dc7301fc0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>currentOutput</b></td></tr>
<tr class="memitem:a2894ec59e252f0a1b8d71ed53def282f" id="r_a2894ec59e252f0a1b8d71ed53def282f"><td class="memItemLeft" align="right" valign="top"><a id="a2894ec59e252f0a1b8d71ed53def282f" name="a2894ec59e252f0a1b8d71ed53def282f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>currentCheckpoint</b></td></tr>
<tr class="memitem:aec48fffb9a0369960b612322089ab22e" id="r_aec48fffb9a0369960b612322089ab22e"><td class="memItemLeft" align="right" valign="top"><a id="aec48fffb9a0369960b612322089ab22e" name="aec48fffb9a0369960b612322089ab22e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>current_grain_reassignment</b></td></tr>
<tr class="memitem:a80715a7978382ae6c146b54036111fc3" id="r_a80715a7978382ae6c146b54036111fc3"><td class="memItemLeft" align="right" valign="top"><a id="a80715a7978382ae6c146b54036111fc3" name="a80715a7978382ae6c146b54036111fc3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_Dirichlet_BCs</b></td></tr>
<tr class="memitem:ac104e3c7a5315b3373003d20e76d02d1" id="r_ac104e3c7a5315b3373003d20e76d02d1"><td class="memItemLeft" align="right" valign="top"><a id="ac104e3c7a5315b3373003d20e76d02d1" name="ac104e3c7a5315b3373003d20e76d02d1"></a>
TimerOutput&#160;</td><td class="memItemRight" valign="bottom"><b>computing_timer</b></td></tr>
<tr class="memitem:a6355da19f5524ccbde54de4c0089b64a" id="r_a6355da19f5524ccbde54de4c0089b64a"><td class="memItemLeft" align="right" valign="top"><a id="a6355da19f5524ccbde54de4c0089b64a" name="a6355da19f5524ccbde54de4c0089b64a"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>integrated_postprocessed_fields</b></td></tr>
<tr class="memitem:a45f5a2f7580a454c2509b3ab4ede4bf5" id="r_a45f5a2f7580a454c2509b3ab4ede4bf5"><td class="memItemLeft" align="right" valign="top"><a id="a45f5a2f7580a454c2509b3ab4ede4bf5" name="a45f5a2f7580a454c2509b3ab4ede4bf5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>first_integrated_var_output_complete</b></td></tr>
<tr class="memitem:a24e69ddc523cf370d9c6e05d43d3e1f4" id="r_a24e69ddc523cf370d9c6e05d43d3e1f4"><td class="memItemLeft" align="right" valign="top"><a id="a24e69ddc523cf370d9c6e05d43d3e1f4" name="a24e69ddc523cf370d9c6e05d43d3e1f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>integrated_var</b></td></tr>
<tr class="memitem:af188e2b0983f44d0f03a262ffd65badb" id="r_af188e2b0983f44d0f03a262ffd65badb"><td class="memItemLeft" align="right" valign="top"><a id="af188e2b0983f44d0f03a262ffd65badb" name="af188e2b0983f44d0f03a262ffd65badb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>integral_index</b></td></tr>
<tr class="memitem:ae341a879b34a9d2176dd49cc573d4a27" id="r_ae341a879b34a9d2176dd49cc573d4a27"><td class="memItemLeft" align="right" valign="top"><a id="ae341a879b34a9d2176dd49cc573d4a27" name="ae341a879b34a9d2176dd49cc573d4a27"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>assembler_lock</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-attribs" class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a062e519cbb15887132641ebbbe0ea25c" id="r_a062e519cbb15887132641ebbbe0ea25c"><td class="memItemLeft" align="right" valign="top"><a id="a062e519cbb15887132641ebbbe0ea25c" name="a062e519cbb15887132641ebbbe0ea25c"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>CIJ_tensor_size</b> = 2 * dim - 1 + dim / 3</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim, int degree&gt;<br />
class MatrixFreePDE&lt; dim, degree &gt;</div><p>This is the abstract base class for the matrix free implementation of parabolic and elliptic BVP's, and supports MPI, threads and vectorization (Hybrid Parallel). This class contains the parallel data structures, mesh (referred to as triangulation), parallel degrees of freedom distribution, constraints, and general utility methods. </p>
<p>All the physical models in this package inherit this base class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The number of dimensions in the problem. </td></tr>
    <tr><td class="paramname">degree</td><td>The polynomial degree of the shape functions. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aeca5bac74a396b8eae8963d22c8bd38e" name="aeca5bac74a396b8eae8963d22c8bd38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca5bac74a396b8eae8963d22c8bd38e">&#9670;&#160;</a></span>adaptiveRefine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::adaptiveRefine </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>_currentIncrement_pf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to control the overall flow of adaptive mesh refinement. </p>

</div>
</div>
<a id="a7aa854c057125670a0fe33aaa66fac7d" name="a7aa854c057125670a0fe33aaa66fac7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa854c057125670a0fe33aaa66fac7d">&#9670;&#160;</a></span>adaptiveRefineCriterion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::adaptiveRefineCriterion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to define the the criterion for refining or coarsening the mesh. This method sets refine/coarsen flags that are read by refineGrid. </p>

</div>
</div>
<a id="a05037ad643070beaf4abc4b4a304b5f2" name="a05037ad643070beaf4abc4b4a304b5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05037ad643070beaf4abc4b4a304b5f2">&#9670;&#160;</a></span>applyDirichletBCs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::applyDirichletBCs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for applying Dirichlet boundary conditions. </p>

</div>
</div>
<a id="a2af67badeaae89034d4cea840514a344" name="a2af67badeaae89034d4cea840514a344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af67badeaae89034d4cea840514a344">&#9670;&#160;</a></span>applyNeumannBCs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::applyNeumannBCs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for applying Neumann boundary conditions. </p>

</div>
</div>
<a id="a30af094d1de94e09be86613649e62521" name="a30af094d1de94e09be86613649e62521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30af094d1de94e09be86613649e62521">&#9670;&#160;</a></span>create_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">parallel::distributed::Triangulation&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tria</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the mesh with the user provided domain sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>Triangulation object. It must be empty prior to calling this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e363551eb34d7f70c0ce1a50af7db9f" name="a5e363551eb34d7f70c0ce1a50af7db9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e363551eb34d7f70c0ce1a50af7db9f">&#9670;&#160;</a></span>initForTests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::initForTests </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_field.html">Field</a>&lt; dim &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>_fields</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the data structures for enabling unit tests. </p>
<p>This method initializes the <a class="el" href="class_matrix_free_p_d_e.html" title="This is the abstract base class for the matrix free implementation of parabolic and elliptic BVP&#39;s,...">MatrixFreePDE</a> object with a fixed geometry, discretization and other custom selected options specifically to help with unit tests, and should not be called in any of the physical models.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_fields</td><td>Vector of PDE descriptions (e.g., scalar/vector) for each field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7975eb6bc4ca5be5c4580a953336a0d3" name="a7975eb6bc4ca5be5c4580a953336a0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7975eb6bc4ca5be5c4580a953336a0d3">&#9670;&#160;</a></span>reassignGrains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::reassignGrains </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to reassign grains when multiple grains are stored in a single order parameter. </p>

</div>
</div>
<a id="afbdc2122f434416ce7cc6f1c0fd3e3cf" name="afbdc2122f434416ce7cc6f1c0fd3e3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdc2122f434416ce7cc6f1c0fd3e3cf">&#9670;&#160;</a></span>refineGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::refineGrid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method that actually changes the triangulation based on refine/coarsen flags set previously. </p>

</div>
</div>
<a id="a22c9cf362995e00bae6a65de2f3fb6ef" name="a22c9cf362995e00bae6a65de2f3fb6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c9cf362995e00bae6a65de2f3fb6ef">&#9670;&#160;</a></span>setInitialCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::setInitialCondition </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar_IC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector_IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the initial condition for all fields. This function is overriden in each application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point at which the initial condition is evaluated. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the field being evaluated. </td></tr>
    <tr><td class="paramname">scalar_IC</td><td>Return variable for scalar fields. </td></tr>
    <tr><td class="paramname">vector_IC</td><td>Return variable for vector fields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ef35cfaad2e31975e8082b38441705" name="a74ef35cfaad2e31975e8082b38441705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef35cfaad2e31975e8082b38441705">&#9670;&#160;</a></span>setNonUniformDirichletBCs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::setNonUniformDirichletBCs </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar_BC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector_BC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the spatially or temporally non-uniform boundary conditions. This function is overriden in each application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point at which the boundary condition is evaluated. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the field being evaluated. </td></tr>
    <tr><td class="paramname">direction</td><td>The face of the boundary condition. </td></tr>
    <tr><td class="paramname">time</td><td>The time at which the boundary condition is evaluated. </td></tr>
    <tr><td class="paramname">scalar_BC</td><td>Return variable for scalar fields. </td></tr>
    <tr><td class="paramname">vector_BC</td><td>Return variable for vector fields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a705efc0da910b53ac9b1af860bbf4e41" name="a705efc0da910b53ac9b1af860bbf4e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705efc0da910b53ac9b1af860bbf4e41">&#9670;&#160;</a></span>setRigidBodyModeConstraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::setRigidBodyModeConstraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>rigidBodyModeComponents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineConstraints&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>dof_handler</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set constraints to pin the solution to 0 at a certain vertex. This is automatically done at the origin if no value terms are detected in your dependencies in a time_independent or implicit solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The constraint set. </td></tr>
    <tr><td class="paramname">dof_handler</td><td>The list of the degrees of freedom. </td></tr>
    <tr><td class="paramname">target_point</td><td>The point where the solution is constrained. This is the origin by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a700088789f8a17c13a76550bd964bd3b" name="a700088789f8a17c13a76550bd964bd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700088789f8a17c13a76550bd964bd3b">&#9670;&#160;</a></span>solveIncrement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::solveIncrement </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_time_dependent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PRISMS-MP: Moved this method to public Method to solve each time increment of a time-dependent problem. For time-independent problems this method is called only once. This method solves for all the fields in a staggered manner (one after another) and also invokes the corresponding solvers: Explicit solver for Parabolic problems, Implicit (matrix-free) solver for Elliptic problems. </p>

</div>
</div>
<a id="a9d7ff2d7a91aa703366bd302495b6678" name="a9d7ff2d7a91aa703366bd302495b6678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7ff2d7a91aa703366bd302495b6678">&#9670;&#160;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int degree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>&lt; dim, degree &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dealii::LinearAlgebra::distributed::Vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method essentially converts the <a class="el" href="class_matrix_free_p_d_e.html" title="This is the abstract base class for the matrix free implementation of parabolic and elliptic BVP&#39;s,...">MatrixFreePDE</a> object into a matrix object which can be used with matrix free iterative solvers. Provides the A*x functionality for solving the system of equations Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination vector. </td></tr>
    <tr><td class="paramname">src</td><td>The source vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/include/<a class="el" href="matrix_free_p_d_e_8h_source.html">matrixFreePDE.h</a></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>boundaryConditions_pf.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>buildFields.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>checkpoint.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>computeIntegral.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>computeLHS.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>computeRHS.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>init_pf.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>initForTests.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>initialConditions.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>invM.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>markBoundaries_pf.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>matrixFreePDE.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>nucleation.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>outputResults.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>postprocessor.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>reassignGrains.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>refine.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>reinit.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>setNonlinearEqInitialGuess.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>solve_pf.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>solveIncrement.cc</b></li>
<li>/Users/dmontiel/Documents/Work/PRISMS/PRISMS-MP_Development/PRISMS-MP_my_fork/multiPhysics/src/multiPhysicsBVP/<b>utilities.cc</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_matrix_free_p_d_e.html">MatrixFreePDE</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
